input AnonymousLoginInput {
  avatarUrl: String
  nickname: String!
}

type AuthResponse {
  accessToken: String!
  user: User!
}

input CreateFriendshipInput {
  followMood: Boolean = false
  recipientId: String!
}

input CreateHugRequestInput {
  isCommunityRequest: Boolean!
  message: String
  recipientId: String
}

input CreateMoodInput {
  isPublic: Boolean!
  note: String
  score: Int!
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

type ExternalRecipient {
  contact: String!
  type: String!
}

input ExternalRecipientInput {
  contact: String!
  type: ExternalRecipientType!
}

"""The type of external recipient contact"""
enum ExternalRecipientType {
  EMAIL
  TELEGRAM
}

type Friendship {
  createdAt: DateTime!
  followsMood: Boolean
  id: ID!
  recipient: User!
  recipientId: String!
  requester: User!
  requesterId: String!
  status: FriendshipStatus!
  updatedAt: DateTime
}

"""The status of a friendship between two users"""
enum FriendshipStatus {
  ACCEPTED
  BLOCKED
  PENDING
  REJECTED
}

type Hug {
  createdAt: DateTime!
  externalRecipient: ExternalRecipient
  id: ID!
  isRead: Boolean!
  message: String
  recipient: User
  recipientId: String
  sender: User!
  senderId: String!
  type: HugType!
}

type HugRequest {
  createdAt: DateTime!
  id: ID!
  isCommunityRequest: Boolean!
  message: String
  recipient: User
  recipientId: String
  requester: User!
  requesterId: String!
  respondedAt: DateTime
  status: HugRequestStatus!
}

"""The status of a hug request"""
enum HugRequestStatus {
  ACCEPTED
  CANCELLED
  DECLINED
  EXPIRED
  PENDING
}

"""The type of hug sent"""
enum HugType {
  CELEBRATORY
  COMFORTING
  ComfortingHug
  ENCOURAGING
  EnthusiasticHug
  FamilyHug
  FriendlyHug
  GentleHug
  GroupHug
  QUICK
  RelaxingHug
  SUPPORTIVE
  SmilingHug
  StandardHug
  SupportiveHug
  VirtualHug
  WARM
  WelcomeHug
}

input LoginInput {
  email: String!
  password: String!
}

type Mood {
  createdAt: DateTime!
  id: ID!
  isPublic: Boolean!
  note: String
  score: Int!
  user: User!
  userId: String!
}

type Mutation {
  anonymousLogin(anonymousLoginInput: AnonymousLoginInput!): AuthResponse!
  cancelHugRequest(requestId: ID!): HugRequest!
  createHugRequest(createHugRequestInput: CreateHugRequestInput!): HugRequest!
  createMood(createMoodInput: CreateMoodInput!): Mood!
  login(loginInput: LoginInput!): AuthResponse!
  markHugAsRead(hugId: ID!): Hug!
  register(registerInput: RegisterInput!): AuthResponse!
  removeMood(id: ID!): Boolean!
  removeUser: Boolean!
  respondToFriendRequest(updateFriendshipInput: UpdateFriendshipInput!): Friendship!
  respondToHugRequest(respondToRequestInput: RespondToRequestInput!): HugRequest!
  sendFriendRequest(createFriendshipInput: CreateFriendshipInput!): Friendship!
  sendHug(sendHugInput: SendHugInput!): Hug!
  updateMood(updateMoodInput: UpdateMoodInput!): Mood!
  updateMoodFollowing(updateFriendshipInput: UpdateFriendshipInput!): Friendship!
  updateUser(updateUserInput: UpdateUserInput!): User!
}

type Query {
  checkFriendship(userId: String!): Boolean!
  communityHugRequests: [HugRequest!]!
  friendsMoods(limit: Float = 20): [Mood!]!
  hug(id: ID!): Hug!
  hugRequest(id: ID!): HugRequest!
  me: User!
  mood(id: ID!): Mood!
  moodFollowing: [Friendship!]!
  moodStreak: Float!
  myFriends: [Friendship!]!
  myHugRequests: [HugRequest!]!
  pendingFriendRequests: [Friendship!]!
  pendingHugRequests: [HugRequest!]!
  publicMoods: [Mood!]!
  receivedHugs: [Hug!]!
  sentFriendRequests: [Friendship!]!
  sentHugs: [Hug!]!
  user(id: ID!): User!
  userMoods: [Mood!]!
  users: [User!]!
}

input RegisterInput {
  avatarUrl: String
  email: String!
  name: String!
  password: String!
  username: String!
}

input RespondToRequestInput {
  message: String
  requestId: String!
  status: HugRequestStatus!
}

input SendHugInput {
  externalRecipient: ExternalRecipientInput
  message: String
  recipientId: String
  type: HugType!
}

input UpdateFriendshipInput {
  followMood: Boolean
  friendshipId: String!
  status: FriendshipStatus
}

input UpdateMoodInput {
  id: ID!
  isPublic: Boolean
  note: String
  score: Int
}

input UpdateUserInput {
  avatarUrl: String
  name: String
  password: String
}

type User {
  avatarUrl: String
  createdAt: DateTime!
  email: String!
  id: ID!
  isAnonymous: Boolean!
  name: String!
  updatedAt: DateTime!
  username: String!
}