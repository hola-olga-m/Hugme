{"version":3,"file":"ErrorMessage-25839d64.js","sources":["../../node_modules/@apollo/client/react/hooks/useSyncExternalStore.js","../../node_modules/@apollo/client/react/hooks/internal/wrapHook.js","../../node_modules/@apollo/client/react/hooks/useQuery.js","../../src/graphql/queries.js","../../src/utils/errorHandling.js","../../src/components/common/ErrorMessage.jsx"],"sourcesContent":["import { invariant } from \"../../utilities/globals/index.js\";\nimport * as React from \"rehackt\";\nimport { canUseLayoutEffect } from \"../../utilities/index.js\";\nvar didWarnUncachedGetSnapshot = false;\n// Prevent webpack from complaining about our feature detection of the\n// useSyncExternalStore property of the React namespace, which is expected not\n// to exist when using React 17 and earlier, and that's fine.\nvar uSESKey = \"useSyncExternalStore\";\nvar realHook = React[uSESKey];\n// Adapted from https://www.npmjs.com/package/use-sync-external-store, with\n// Apollo Client deviations called out by \"// DEVIATION ...\" comments.\n// When/if React.useSyncExternalStore is defined, delegate fully to it.\nexport var useSyncExternalStore = realHook ||\n    (function (subscribe, getSnapshot, getServerSnapshot) {\n        // Read the current snapshot from the store on every render. Again, this\n        // breaks the rules of React, and only works here because of specific\n        // implementation details, most importantly that updates are\n        // always synchronous.\n        var value = getSnapshot();\n        if (\n        // DEVIATION: Using __DEV__\n        globalThis.__DEV__ !== false &&\n            !didWarnUncachedGetSnapshot &&\n            // DEVIATION: Not using Object.is because we know our snapshots will never\n            // be exotic primitive values like NaN, which is !== itself.\n            value !== getSnapshot()) {\n            didWarnUncachedGetSnapshot = true;\n            // DEVIATION: Using invariant.error instead of console.error directly.\n            globalThis.__DEV__ !== false && invariant.error(68);\n        }\n        // Because updates are synchronous, we don't queue them. Instead we force a\n        // re-render whenever the subscribed state changes by updating an some\n        // arbitrary useState hook. Then, during render, we call getSnapshot to read\n        // the current value.\n        //\n        // Because we don't actually use the state returned by the useState hook, we\n        // can save a bit of memory by storing other stuff in that slot.\n        //\n        // To implement the early bailout, we need to track some things on a mutable\n        // object. Usually, we would put that in a useRef hook, but we can stash it in\n        // our useState hook instead.\n        //\n        // To force a re-render, we call forceUpdate({inst}). That works because the\n        // new object always fails an equality check.\n        var _a = React.useState({\n            inst: { value: value, getSnapshot: getSnapshot },\n        }), inst = _a[0].inst, forceUpdate = _a[1];\n        // Track the latest getSnapshot function with a ref. This needs to be updated\n        // in the layout phase so we can access it during the tearing check that\n        // happens on subscribe.\n        if (canUseLayoutEffect) {\n            // DEVIATION: We avoid calling useLayoutEffect when !canUseLayoutEffect,\n            // which may seem like a conditional hook, but this code ends up behaving\n            // unconditionally (one way or the other) because canUseLayoutEffect is\n            // constant.\n            React.useLayoutEffect(function () {\n                Object.assign(inst, { value: value, getSnapshot: getSnapshot });\n                // Whenever getSnapshot or subscribe changes, we need to check in the\n                // commit phase if there was an interleaved mutation. In concurrent mode\n                // this can happen all the time, but even in synchronous mode, an earlier\n                // effect may have mutated the store.\n                if (checkIfSnapshotChanged(inst)) {\n                    // Force a re-render.\n                    forceUpdate({ inst: inst });\n                }\n                // React Hook React.useLayoutEffect has a missing dependency: 'inst'. Either include it or remove the dependency array.\n                // eslint-disable-next-line react-hooks/exhaustive-deps\n            }, [subscribe, value, getSnapshot]);\n        }\n        else {\n            Object.assign(inst, { value: value, getSnapshot: getSnapshot });\n        }\n        React.useEffect(function () {\n            // Check for changes right before subscribing. Subsequent changes will be\n            // detected in the subscription handler.\n            if (checkIfSnapshotChanged(inst)) {\n                // Force a re-render.\n                forceUpdate({ inst: inst });\n            }\n            // Subscribe to the store and return a clean-up function.\n            return subscribe(function handleStoreChange() {\n                // TODO: Because there is no cross-renderer API for batching updates, it's\n                // up to the consumer of this library to wrap their subscription event\n                // with unstable_batchedUpdates. Should we try to detect when this isn't\n                // the case and print a warning in development?\n                // The store changed. Check if the snapshot changed since the last time we\n                // read from the store.\n                if (checkIfSnapshotChanged(inst)) {\n                    // Force a re-render.\n                    forceUpdate({ inst: inst });\n                }\n            });\n            // React Hook React.useEffect has a missing dependency: 'inst'. Either include it or remove the dependency array.\n            // eslint-disable-next-line react-hooks/exhaustive-deps\n        }, [subscribe]);\n        return value;\n    });\nfunction checkIfSnapshotChanged(_a) {\n    var value = _a.value, getSnapshot = _a.getSnapshot;\n    try {\n        return value !== getSnapshot();\n    }\n    catch (_b) {\n        return true;\n    }\n}\n//# sourceMappingURL=useSyncExternalStore.js.map","var wrapperSymbol = Symbol.for(\"apollo.hook.wrappers\");\n/**\n * @internal\n *\n * Makes an Apollo Client hook \"wrappable\".\n * That means that the Apollo Client instance can expose a \"wrapper\" that will be\n * used to wrap the original hook implementation with additional logic.\n * @example\n * ```tsx\n * // this is already done in `@apollo/client` for all wrappable hooks (see `WrappableHooks`)\n * // following this pattern\n * function useQuery() {\n *   return wrapHook('useQuery', _useQuery, options.client)(query, options);\n * }\n * function _useQuery(query, options) {\n *   // original implementation\n * }\n *\n * // this is what a library like `@apollo/client-react-streaming` would do\n * class ApolloClientWithStreaming extends ApolloClient {\n *   constructor(options) {\n *     super(options);\n *     this.queryManager[Symbol.for(\"apollo.hook.wrappers\")] = {\n *       useQuery: (original) => (query, options) => {\n *         console.log(\"useQuery was called with options\", options);\n *         return original(query, options);\n *       }\n *     }\n *   }\n * }\n *\n * // this will now log the options and then call the original `useQuery`\n * const client = new ApolloClientWithStreaming({ ... });\n * useQuery(query, { client });\n * ```\n */\nexport function wrapHook(hookName, useHook, clientOrObsQuery) {\n    var queryManager = clientOrObsQuery[\"queryManager\"];\n    var wrappers = queryManager && queryManager[wrapperSymbol];\n    var wrapper = wrappers && wrappers[hookName];\n    return wrapper ? wrapper(useHook) : useHook;\n}\n//# sourceMappingURL=wrapHook.js.map","import { __assign, __rest } from \"tslib\";\n/**\n * Function parameters in this file try to follow a common order for the sake of\n * readability and consistency. The order is as follows:\n *\n * resultData\n * observable\n * client\n * query\n * options\n * watchQueryOptions\n * makeWatchQueryOptions\n * isSSRAllowed\n * disableNetworkFetches\n * partialRefetch\n * renderPromises\n * isSyncSSR\n * callbacks\n */\n/** */\nimport { invariant } from \"../../utilities/globals/index.js\";\nimport * as React from \"rehackt\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\nimport { equal } from \"@wry/equality\";\nimport { mergeOptions } from \"../../utilities/index.js\";\nimport { getApolloContext } from \"../context/index.js\";\nimport { ApolloError } from \"../../errors/index.js\";\nimport { NetworkStatus } from \"../../core/index.js\";\nimport { DocumentType, verifyDocumentType } from \"../parser/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { compact, isNonEmptyArray, maybeDeepFreeze, } from \"../../utilities/index.js\";\nimport { wrapHook } from \"./internal/index.js\";\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction noop() { }\nvar lastWatchOptions = Symbol();\n/**\n * A hook for executing queries in an Apollo application.\n *\n * To run a query within a React component, call `useQuery` and pass it a GraphQL query document.\n *\n * When your component renders, `useQuery` returns an object from Apollo Client that contains `loading`, `error`, and `data` properties you can use to render your UI.\n *\n * > Refer to the [Queries](https://www.apollographql.com/docs/react/data/queries) section for a more in-depth overview of `useQuery`.\n *\n * @example\n * ```jsx\n * import { gql, useQuery } from '@apollo/client';\n *\n * const GET_GREETING = gql`\n *   query GetGreeting($language: String!) {\n *     greeting(language: $language) {\n *       message\n *     }\n *   }\n * `;\n *\n * function Hello() {\n *   const { loading, error, data } = useQuery(GET_GREETING, {\n *     variables: { language: 'english' },\n *   });\n *   if (loading) return <p>Loading ...</p>;\n *   return <h1>Hello {data.greeting.message}!</h1>;\n * }\n * ```\n * @since 3.0.0\n * @param query - A GraphQL query document parsed into an AST by `gql`.\n * @param options - Options to control how the query is executed.\n * @returns Query result object\n */\nexport function useQuery(query, options) {\n    if (options === void 0) { options = Object.create(null); }\n    return wrapHook(\"useQuery\", \n    // eslint-disable-next-line react-compiler/react-compiler\n    useQuery_, useApolloClient(options && options.client))(query, options);\n}\nfunction useQuery_(query, options) {\n    var _a = useQueryInternals(query, options), result = _a.result, obsQueryFields = _a.obsQueryFields;\n    return React.useMemo(function () { return (__assign(__assign({}, result), obsQueryFields)); }, [result, obsQueryFields]);\n}\nfunction useInternalState(client, query, options, renderPromises, makeWatchQueryOptions) {\n    function createInternalState(previous) {\n        var _a;\n        verifyDocumentType(query, DocumentType.Query);\n        var internalState = {\n            client: client,\n            query: query,\n            observable: \n            // See if there is an existing observable that was used to fetch the same\n            // data and if so, use it instead since it will contain the proper queryId\n            // to fetch the result set. This is used during SSR.\n            (renderPromises &&\n                renderPromises.getSSRObservable(makeWatchQueryOptions())) ||\n                client.watchQuery(getObsQueryOptions(void 0, client, options, makeWatchQueryOptions())),\n            resultData: {\n                // Reuse previousData from previous InternalState (if any) to provide\n                // continuity of previousData even if/when the query or client changes.\n                previousData: (_a = previous === null || previous === void 0 ? void 0 : previous.resultData.current) === null || _a === void 0 ? void 0 : _a.data,\n            },\n        };\n        return internalState;\n    }\n    var _a = React.useState(createInternalState), internalState = _a[0], updateInternalState = _a[1];\n    /**\n     * Used by `useLazyQuery` when a new query is executed.\n     * We keep this logic here since it needs to update things in unsafe\n     * ways and here we at least can keep track of that in a single place.\n     */\n    function onQueryExecuted(watchQueryOptions) {\n        var _a;\n        var _b;\n        // this needs to be set to prevent an immediate `resubscribe` in the\n        // next rerender of the `useQuery` internals\n        Object.assign(internalState.observable, (_a = {},\n            _a[lastWatchOptions] = watchQueryOptions,\n            _a));\n        var resultData = internalState.resultData;\n        updateInternalState(__assign(__assign({}, internalState), { \n            // might be a different query\n            query: watchQueryOptions.query, resultData: Object.assign(resultData, {\n                // We need to modify the previous `resultData` object as we rely on the\n                // object reference in other places\n                previousData: ((_b = resultData.current) === null || _b === void 0 ? void 0 : _b.data) || resultData.previousData,\n                current: undefined,\n            }) }));\n    }\n    if (client !== internalState.client || query !== internalState.query) {\n        // If the client or query have changed, we need to create a new InternalState.\n        // This will trigger a re-render with the new state, but it will also continue\n        // to run the current render function to completion.\n        // Since we sometimes trigger some side-effects in the render function, we\n        // re-assign `state` to the new state to ensure that those side-effects are\n        // triggered with the new state.\n        var newInternalState = createInternalState(internalState);\n        updateInternalState(newInternalState);\n        return [newInternalState, onQueryExecuted];\n    }\n    return [internalState, onQueryExecuted];\n}\nexport function useQueryInternals(query, options) {\n    var client = useApolloClient(options.client);\n    var renderPromises = React.useContext(getApolloContext()).renderPromises;\n    var isSyncSSR = !!renderPromises;\n    var disableNetworkFetches = client.disableNetworkFetches;\n    var ssrAllowed = options.ssr !== false && !options.skip;\n    var partialRefetch = options.partialRefetch;\n    var makeWatchQueryOptions = createMakeWatchQueryOptions(client, query, options, isSyncSSR);\n    var _a = useInternalState(client, query, options, renderPromises, makeWatchQueryOptions), _b = _a[0], observable = _b.observable, resultData = _b.resultData, onQueryExecuted = _a[1];\n    var watchQueryOptions = makeWatchQueryOptions(observable);\n    useResubscribeIfNecessary(resultData, // might get mutated during render\n    observable, // might get mutated during render\n    client, options, watchQueryOptions);\n    var obsQueryFields = React.useMemo(function () { return bindObservableMethods(observable); }, [observable]);\n    useRegisterSSRObservable(observable, renderPromises, ssrAllowed);\n    var result = useObservableSubscriptionResult(resultData, observable, client, options, watchQueryOptions, disableNetworkFetches, partialRefetch, isSyncSSR, {\n        onCompleted: options.onCompleted || noop,\n        onError: options.onError || noop,\n    });\n    return {\n        result: result,\n        obsQueryFields: obsQueryFields,\n        observable: observable,\n        resultData: resultData,\n        client: client,\n        onQueryExecuted: onQueryExecuted,\n    };\n}\nfunction useObservableSubscriptionResult(resultData, observable, client, options, watchQueryOptions, disableNetworkFetches, partialRefetch, isSyncSSR, callbacks) {\n    var callbackRef = React.useRef(callbacks);\n    React.useEffect(function () {\n        // Make sure state.onCompleted and state.onError always reflect the latest\n        // options.onCompleted and options.onError callbacks provided to useQuery,\n        // since those functions are often recreated every time useQuery is called.\n        // Like the forceUpdate method, the versions of these methods inherited from\n        // InternalState.prototype are empty no-ops, but we can override them on the\n        // base state object (without modifying the prototype).\n        // eslint-disable-next-line react-compiler/react-compiler\n        callbackRef.current = callbacks;\n    });\n    var resultOverride = ((isSyncSSR || disableNetworkFetches) &&\n        options.ssr === false &&\n        !options.skip) ?\n        // If SSR has been explicitly disabled, and this function has been called\n        // on the server side, return the default loading state.\n        ssrDisabledResult\n        : options.skip || watchQueryOptions.fetchPolicy === \"standby\" ?\n            // When skipping a query (ie. we're not querying for data but still want to\n            // render children), make sure the `data` is cleared out and `loading` is\n            // set to `false` (since we aren't loading anything).\n            //\n            // NOTE: We no longer think this is the correct behavior. Skipping should\n            // not automatically set `data` to `undefined`, but instead leave the\n            // previous data in place. In other words, skipping should not mandate that\n            // previously received data is all of a sudden removed. Unfortunately,\n            // changing this is breaking, so we'll have to wait until Apollo Client 4.0\n            // to address this.\n            skipStandbyResult\n            : void 0;\n    var previousData = resultData.previousData;\n    var currentResultOverride = React.useMemo(function () {\n        return resultOverride &&\n            toQueryResult(resultOverride, previousData, observable, client);\n    }, [client, observable, resultOverride, previousData]);\n    return useSyncExternalStore(React.useCallback(function (handleStoreChange) {\n        // reference `disableNetworkFetches` here to ensure that the rules of hooks\n        // keep it as a dependency of this effect, even though it's not used\n        disableNetworkFetches;\n        if (isSyncSSR) {\n            return function () { };\n        }\n        var onNext = function () {\n            var previousResult = resultData.current;\n            // We use `getCurrentResult()` instead of the onNext argument because\n            // the values differ slightly. Specifically, loading results will have\n            // an empty object for data instead of `undefined` for some reason.\n            var result = observable.getCurrentResult();\n            // Make sure we're not attempting to re-render similar results\n            if (previousResult &&\n                previousResult.loading === result.loading &&\n                previousResult.networkStatus === result.networkStatus &&\n                equal(previousResult.data, result.data)) {\n                return;\n            }\n            setResult(result, resultData, observable, client, partialRefetch, handleStoreChange, callbackRef.current);\n        };\n        var onError = function (error) {\n            subscription.current.unsubscribe();\n            subscription.current = observable.resubscribeAfterError(onNext, onError);\n            if (!hasOwnProperty.call(error, \"graphQLErrors\")) {\n                // The error is not a GraphQL error\n                throw error;\n            }\n            var previousResult = resultData.current;\n            if (!previousResult ||\n                (previousResult && previousResult.loading) ||\n                !equal(error, previousResult.error)) {\n                setResult({\n                    data: (previousResult &&\n                        previousResult.data),\n                    error: error,\n                    loading: false,\n                    networkStatus: NetworkStatus.error,\n                }, resultData, observable, client, partialRefetch, handleStoreChange, callbackRef.current);\n            }\n        };\n        // TODO evaluate if we keep this in\n        // React Compiler cannot handle scoped `let` access, but a mutable object\n        // like this is fine.\n        // was:\n        // let subscription = observable.subscribe(onNext, onError);\n        var subscription = { current: observable.subscribe(onNext, onError) };\n        // Do the \"unsubscribe\" with a short delay.\n        // This way, an existing subscription can be reused without an additional\n        // request if \"unsubscribe\"  and \"resubscribe\" to the same ObservableQuery\n        // happen in very fast succession.\n        return function () {\n            setTimeout(function () { return subscription.current.unsubscribe(); });\n        };\n    }, [\n        disableNetworkFetches,\n        isSyncSSR,\n        observable,\n        resultData,\n        partialRefetch,\n        client,\n    ]), function () {\n        return currentResultOverride ||\n            getCurrentResult(resultData, observable, callbackRef.current, partialRefetch, client);\n    }, function () {\n        return currentResultOverride ||\n            getCurrentResult(resultData, observable, callbackRef.current, partialRefetch, client);\n    });\n}\nfunction useRegisterSSRObservable(observable, renderPromises, ssrAllowed) {\n    if (renderPromises && ssrAllowed) {\n        renderPromises.registerSSRObservable(observable);\n        if (observable.getCurrentResult().loading) {\n            // TODO: This is a legacy API which could probably be cleaned up\n            renderPromises.addObservableQueryPromise(observable);\n        }\n    }\n}\n// this hook is not compatible with any rules of React, and there's no good way to rewrite it.\n// it should stay a separate hook that will not be optimized by the compiler\nfunction useResubscribeIfNecessary(\n/** this hook will mutate properties on `resultData` */\nresultData, \n/** this hook will mutate properties on `observable` */\nobservable, client, options, watchQueryOptions) {\n    var _a;\n    if (observable[lastWatchOptions] &&\n        !equal(observable[lastWatchOptions], watchQueryOptions)) {\n        // Though it might be tempting to postpone this reobserve call to the\n        // useEffect block, we need getCurrentResult to return an appropriate\n        // loading:true result synchronously (later within the same call to\n        // useQuery). Since we already have this.observable here (not true for\n        // the very first call to useQuery), we are not initiating any new\n        // subscriptions, though it does feel less than ideal that reobserve\n        // (potentially) kicks off a network request (for example, when the\n        // variables have changed), which is technically a side-effect.\n        observable.reobserve(getObsQueryOptions(observable, client, options, watchQueryOptions));\n        // Make sure getCurrentResult returns a fresh ApolloQueryResult<TData>,\n        // but save the current data as this.previousData, just like setResult\n        // usually does.\n        resultData.previousData =\n            ((_a = resultData.current) === null || _a === void 0 ? void 0 : _a.data) || resultData.previousData;\n        resultData.current = void 0;\n    }\n    observable[lastWatchOptions] = watchQueryOptions;\n}\n/*\n * A function to massage options before passing them to ObservableQuery.\n * This is two-step curried because we want to reuse the `make` function,\n * but the `observable` might differ between calls to `make`.\n */\nexport function createMakeWatchQueryOptions(client, query, _a, isSyncSSR) {\n    if (_a === void 0) { _a = {}; }\n    var skip = _a.skip, ssr = _a.ssr, onCompleted = _a.onCompleted, onError = _a.onError, defaultOptions = _a.defaultOptions, \n    // The above options are useQuery-specific, so this ...otherOptions spread\n    // makes otherOptions almost a WatchQueryOptions object, except for the\n    // query property that we add below.\n    otherOptions = __rest(_a, [\"skip\", \"ssr\", \"onCompleted\", \"onError\", \"defaultOptions\"]);\n    return function (observable) {\n        // This Object.assign is safe because otherOptions is a fresh ...rest object\n        // that did not exist until just now, so modifications are still allowed.\n        var watchQueryOptions = Object.assign(otherOptions, { query: query });\n        if (isSyncSSR &&\n            (watchQueryOptions.fetchPolicy === \"network-only\" ||\n                watchQueryOptions.fetchPolicy === \"cache-and-network\")) {\n            // this behavior was added to react-apollo without explanation in this PR\n            // https://github.com/apollographql/react-apollo/pull/1579\n            watchQueryOptions.fetchPolicy = \"cache-first\";\n        }\n        if (!watchQueryOptions.variables) {\n            watchQueryOptions.variables = {};\n        }\n        if (skip) {\n            // When skipping, we set watchQueryOptions.fetchPolicy initially to\n            // \"standby\", but we also need/want to preserve the initial non-standby\n            // fetchPolicy that would have been used if not skipping.\n            watchQueryOptions.initialFetchPolicy =\n                watchQueryOptions.initialFetchPolicy ||\n                    watchQueryOptions.fetchPolicy ||\n                    getDefaultFetchPolicy(defaultOptions, client.defaultOptions);\n            watchQueryOptions.fetchPolicy = \"standby\";\n        }\n        else if (!watchQueryOptions.fetchPolicy) {\n            watchQueryOptions.fetchPolicy =\n                (observable === null || observable === void 0 ? void 0 : observable.options.initialFetchPolicy) ||\n                    getDefaultFetchPolicy(defaultOptions, client.defaultOptions);\n        }\n        return watchQueryOptions;\n    };\n}\nexport function getObsQueryOptions(observable, client, queryHookOptions, watchQueryOptions) {\n    var toMerge = [];\n    var globalDefaults = client.defaultOptions.watchQuery;\n    if (globalDefaults)\n        toMerge.push(globalDefaults);\n    if (queryHookOptions.defaultOptions) {\n        toMerge.push(queryHookOptions.defaultOptions);\n    }\n    // We use compact rather than mergeOptions for this part of the merge,\n    // because we want watchQueryOptions.variables (if defined) to replace\n    // this.observable.options.variables whole. This replacement allows\n    // removing variables by removing them from the variables input to\n    // useQuery. If the variables were always merged together (rather than\n    // replaced), there would be no way to remove existing variables.\n    // However, the variables from options.defaultOptions and globalDefaults\n    // (if provided) should be merged, to ensure individual defaulted\n    // variables always have values, if not otherwise defined in\n    // observable.options or watchQueryOptions.\n    toMerge.push(compact(observable && observable.options, watchQueryOptions));\n    return toMerge.reduce(mergeOptions);\n}\nfunction setResult(nextResult, resultData, observable, client, partialRefetch, forceUpdate, callbacks) {\n    var previousResult = resultData.current;\n    if (previousResult && previousResult.data) {\n        resultData.previousData = previousResult.data;\n    }\n    if (!nextResult.error && isNonEmptyArray(nextResult.errors)) {\n        // Until a set naming convention for networkError and graphQLErrors is\n        // decided upon, we map errors (graphQLErrors) to the error options.\n        // TODO: Is it possible for both result.error and result.errors to be\n        // defined here?\n        nextResult.error = new ApolloError({ graphQLErrors: nextResult.errors });\n    }\n    resultData.current = toQueryResult(unsafeHandlePartialRefetch(nextResult, observable, partialRefetch), resultData.previousData, observable, client);\n    // Calling state.setResult always triggers an update, though some call sites\n    // perform additional equality checks before committing to an update.\n    forceUpdate();\n    handleErrorOrCompleted(nextResult, previousResult === null || previousResult === void 0 ? void 0 : previousResult.networkStatus, callbacks);\n}\nfunction handleErrorOrCompleted(result, previousNetworkStatus, callbacks) {\n    if (!result.loading) {\n        var error_1 = toApolloError(result);\n        // wait a tick in case we are in the middle of rendering a component\n        Promise.resolve()\n            .then(function () {\n            if (error_1) {\n                callbacks.onError(error_1);\n            }\n            else if (result.data &&\n                previousNetworkStatus !== result.networkStatus &&\n                result.networkStatus === NetworkStatus.ready) {\n                callbacks.onCompleted(result.data);\n            }\n        })\n            .catch(function (error) {\n            globalThis.__DEV__ !== false && invariant.warn(error);\n        });\n    }\n}\nfunction getCurrentResult(resultData, observable, callbacks, partialRefetch, client) {\n    // Using this.result as a cache ensures getCurrentResult continues returning\n    // the same (===) result object, unless state.setResult has been called, or\n    // we're doing server rendering and therefore override the result below.\n    if (!resultData.current) {\n        // WARNING: SIDE-EFFECTS IN THE RENDER FUNCTION\n        // this could call unsafeHandlePartialRefetch\n        setResult(observable.getCurrentResult(), resultData, observable, client, partialRefetch, function () { }, callbacks);\n    }\n    return resultData.current;\n}\nexport function getDefaultFetchPolicy(queryHookDefaultOptions, clientDefaultOptions) {\n    var _a;\n    return ((queryHookDefaultOptions === null || queryHookDefaultOptions === void 0 ? void 0 : queryHookDefaultOptions.fetchPolicy) ||\n        ((_a = clientDefaultOptions === null || clientDefaultOptions === void 0 ? void 0 : clientDefaultOptions.watchQuery) === null || _a === void 0 ? void 0 : _a.fetchPolicy) ||\n        \"cache-first\");\n}\nexport function toApolloError(result) {\n    return isNonEmptyArray(result.errors) ?\n        new ApolloError({ graphQLErrors: result.errors })\n        : result.error;\n}\nexport function toQueryResult(result, previousData, observable, client) {\n    var data = result.data, partial = result.partial, resultWithoutPartial = __rest(result, [\"data\", \"partial\"]);\n    var queryResult = __assign(__assign({ data: data }, resultWithoutPartial), { client: client, observable: observable, variables: observable.variables, called: result !== ssrDisabledResult && result !== skipStandbyResult, previousData: previousData });\n    return queryResult;\n}\nfunction unsafeHandlePartialRefetch(result, observable, partialRefetch) {\n    // TODO: This code should be removed when the partialRefetch option is\n    // removed. I was unable to get this hook to behave reasonably in certain\n    // edge cases when this block was put in an effect.\n    if (result.partial &&\n        partialRefetch &&\n        !result.loading &&\n        (!result.data || Object.keys(result.data).length === 0) &&\n        observable.options.fetchPolicy !== \"cache-only\") {\n        observable.refetch();\n        return __assign(__assign({}, result), { loading: true, networkStatus: NetworkStatus.refetch });\n    }\n    return result;\n}\nvar ssrDisabledResult = maybeDeepFreeze({\n    loading: true,\n    data: void 0,\n    error: void 0,\n    networkStatus: NetworkStatus.loading,\n});\nvar skipStandbyResult = maybeDeepFreeze({\n    loading: false,\n    data: void 0,\n    error: void 0,\n    networkStatus: NetworkStatus.ready,\n});\nfunction bindObservableMethods(observable) {\n    return {\n        refetch: observable.refetch.bind(observable),\n        reobserve: observable.reobserve.bind(observable),\n        fetchMore: observable.fetchMore.bind(observable),\n        updateQuery: observable.updateQuery.bind(observable),\n        startPolling: observable.startPolling.bind(observable),\n        stopPolling: observable.stopPolling.bind(observable),\n        subscribeToMore: observable.subscribeToMore.bind(observable),\n    };\n}\n//# sourceMappingURL=useQuery.js.map","import { gql } from '@apollo/client';\n\n// User queries\nexport const GET_ME = gql`\n  query me {\n    me {\n      id\n      username\n      email\n      name\n      avatarUrl\n      isAnonymous\n      createdAt\n      updatedAt\n    }\n  }\n`;\n\nexport const GET_USER = gql`\n  query user($id: ID!) {\n    user(id: $id) {\n      id\n      username\n      email\n      name\n      avatarUrl\n      isAnonymous\n      createdAt\n      updatedAt\n    }\n  }\n`;\n\nexport const GET_USERS = gql`\n  query users {\n    users {\n      id\n      username\n      name\n      avatarUrl\n      isAnonymous\n    }\n  }\n`;\n\n// Mood queries\nexport const GET_USER_MOODS = gql`\n  query userMoods {\n    userMoods {\n      id\n      score\n      note\n      isPublic\n      createdAt\n      userId\n    }\n  }\n`;\n\nexport const GET_PUBLIC_MOODS = gql`\n  query publicMoods {\n    publicMoods {\n      id\n      score\n      note\n      createdAt\n      user {\n        id\n        username\n        name\n        avatarUrl\n      }\n    }\n  }\n`;\n\nexport const GET_MOOD = gql`\n  query mood($id: ID!) {\n    mood(id: $id) {\n      id\n      score\n      note\n      isPublic\n      createdAt\n      userId\n    }\n  }\n`;\n\nexport const GET_MOOD_STREAK = gql`\n  query moodStreak {\n    moodStreak\n  }\n`;\n\n// Hug queries\nexport const GET_SENT_HUGS = gql`\n  query sentHugs {\n    sentHugs {\n      id\n      type\n      message\n      isRead\n      createdAt\n      recipient {\n        id\n        username\n        name\n        avatarUrl\n      }\n    }\n  }\n`;\n\nexport const GET_RECEIVED_HUGS = gql`\n  query receivedHugs {\n    receivedHugs {\n      id\n      type\n      message\n      isRead\n      createdAt\n      sender {\n        id\n        username\n        name\n        avatarUrl\n      }\n    }\n  }\n`;\n\nexport const GET_HUG = gql`\n  query hug($id: ID!) {\n    hug(id: $id) {\n      id\n      type\n      message\n      isRead\n      createdAt\n      sender {\n        id\n        username\n        name\n      }\n      recipient {\n        id\n        username\n        name\n      }\n    }\n  }\n`;\n\n// Hug Request queries\nexport const GET_MY_HUG_REQUESTS = gql`\n  query myHugRequests {\n    myHugRequests {\n      id\n      message\n      isCommunityRequest\n      status\n      createdAt\n      respondedAt\n      recipient {\n        id\n        username\n        name\n        avatarUrl\n      }\n    }\n  }\n`;\n\nexport const GET_PENDING_HUG_REQUESTS = gql`\n  query pendingHugRequests {\n    pendingHugRequests {\n      id\n      message\n      isCommunityRequest\n      status\n      createdAt\n      requester {\n        id\n        username\n        name\n        avatarUrl\n      }\n    }\n  }\n`;\n\nexport const GET_COMMUNITY_HUG_REQUESTS = gql`\n  query communityHugRequests {\n    communityHugRequests {\n      id\n      message\n      isCommunityRequest\n      status\n      createdAt\n      requester {\n        id\n        username\n        name\n        avatarUrl\n      }\n    }\n  }\n`;\n\nexport const GET_HUG_REQUEST = gql`\n  query hugRequest($id: ID!) {\n    hugRequest(id: $id) {\n      id\n      message\n      isCommunityRequest\n      status\n      createdAt\n      respondedAt\n      requester {\n        id\n        username\n        name\n        avatarUrl\n      }\n      recipient {\n        id\n        username\n        name\n        avatarUrl\n      }\n    }\n  }\n`;\n\n// Stats queries\nexport const GET_USER_STATS = gql`\n  query userStats {\n    me {\n      id\n      receivedHugs {\n        id\n      }\n      sentHugs {\n        id\n      }\n    }\n    moodStreak\n  }\n`;","/**\n * Utility functions for error handling and detection\n */\n\n/**\n * Detects the type of error based on error message and context\n * @param {Error} error - The error object\n * @param {Object} context - Additional context about where the error occurred\n * @returns {string} Error type: 'route', 'network', 'auth', 'data'\n */\nexport const detectErrorType = (error, context = {}) => {\n  const message = error?.message?.toLowerCase() || '';\n  \n  // Authentication errors\n  if (\n    message.includes('unauthorized') ||\n    message.includes('unauthenticated') ||\n    message.includes('auth') ||\n    message.includes('login') ||\n    message.includes('token') ||\n    error?.status === 401 ||\n    error?.statusCode === 401\n  ) {\n    return 'auth';\n  }\n  \n  // Network errors\n  if (\n    message.includes('network') ||\n    message.includes('connection') ||\n    message.includes('offline') ||\n    message.includes('failed to fetch') ||\n    error.name === 'NetworkError' ||\n    context.isNetworkError\n  ) {\n    return 'network';\n  }\n  \n  // Routing errors\n  if (\n    message.includes('not found') ||\n    message.includes('404') ||\n    message.includes('route') ||\n    error?.status === 404 ||\n    error?.statusCode === 404 ||\n    context.isRouteError\n  ) {\n    return 'route';\n  }\n  \n  // Data errors (validation, database, etc.)\n  if (\n    message.includes('validation') ||\n    message.includes('invalid') ||\n    message.includes('data') ||\n    message.includes('database') ||\n    message.includes('constraint') ||\n    context.isDataError\n  ) {\n    return 'data';\n  }\n  \n  // Default to general error\n  return 'general';\n};\n\n/**\n * Get user-friendly error message based on error type\n * @param {string} errorType - The type of error\n * @returns {Object} Object with title and description\n */\nexport const getErrorMessage = (errorType) => {\n  switch (errorType) {\n    case 'auth':\n      return {\n        title: 'Authentication Error',\n        description: 'Your session may have expired. Please log in again.'\n      };\n    case 'network':\n      return {\n        title: 'Network Error',\n        description: 'Unable to connect to the server. Please check your internet connection.'\n      };\n    case 'route':\n      return {\n        title: 'Page Not Found',\n        description: 'The page you are looking for does not exist or has been moved.'\n      };\n    case 'data':\n      return {\n        title: 'Data Error',\n        description: 'There was a problem with the data. Please try again with valid information.'\n      };\n    default:\n      return {\n        title: 'Something Went Wrong',\n        description: 'An unexpected error occurred. Please try again later.'\n      };\n  }\n};\n\n/**\n * Log error details for debugging\n * @param {Error} error - The error object\n * @param {Object} context - Additional context\n */\nexport const logError = (error, context = {}) => {\n  const errorType = detectErrorType(error, context);\n  const { title } = getErrorMessage(errorType);\n  \n  console.group(`Error: ${title}`);\n  console.error('Error object:', error);\n  console.error('Error name:', error?.name);\n  console.error('Error message:', error?.message);\n  console.error('Error stack:', error?.stack);\n  console.error('Error type:', errorType);\n  console.error('Error context:', context);\n  \n  // Log \"y is not iterable\" specific debugging info\n  if (error?.message?.includes('is not iterable')) {\n    console.error('Iterable error detected. Variable info:');\n    console.error('Variable type:', typeof error?.y);\n    console.error('Variable value:', error?.y);\n    console.error('Current component:', context?.component || 'Unknown');\n  }\n  \n  console.groupEnd();\n  \n  // Could add additional logging here, e.g. to an error tracking service\n};\n\n/**\n * Determine the appropriate redirect for an error\n * @param {string} errorType - The type of error\n * @returns {string} The path to redirect to\n */\nexport const getErrorRedirect = (errorType) => {\n  switch (errorType) {\n    case 'auth':\n      return '/login';\n    case 'route':\n      return '/';\n    case 'network':\n    case 'data':\n    default:\n      // Stay on the current page for these errors\n      return null;\n  }\n};","import React from 'react';\nimport styled from 'styled-components';\nimport { detectErrorType, getErrorMessage } from '../../utils/errorHandling';\n\nconst ErrorContainer = styled.div`\n  background-color: var(--danger-light);\n  border-left: 4px solid var(--danger-color);\n  color: var(--danger-dark);\n  padding: 1rem;\n  margin-bottom: 1.5rem;\n  border-radius: var(--border-radius);\n`;\n\nconst ErrorTitle = styled.h3`\n  margin: 0 0 0.5rem 0;\n  font-size: 1rem;\n`;\n\nconst ErrorDetails = styled.p`\n  margin: 0;\n  font-size: 0.9rem;\n`;\n\nconst ErrorAction = styled.div`\n  margin-top: 0.75rem;\n  \n  button {\n    background: none;\n    border: none;\n    color: var(--danger-dark);\n    text-decoration: underline;\n    cursor: pointer;\n    padding: 0;\n    font-size: 0.9rem;\n  }\n`;\n\nconst ErrorMessage = ({ error, context = {} }) => {\n  // Default error if none provided\n  if (!error) {\n    return (\n      <ErrorContainer>\n        <ErrorTitle>An unknown error occurred</ErrorTitle>\n        <ErrorDetails>\n          Please try again later or contact support if the problem persists.\n        </ErrorDetails>\n      </ErrorContainer>\n    );\n  }\n\n  // Parse the error\n  const errorType = detectErrorType(error, context);\n  const errorMessage = getErrorMessage(errorType);\n  \n  // Get the error message (might be nested in different ways)\n  const message = error.message || \n                 (error.graphQLErrors && error.graphQLErrors[0]?.message) || \n                 'An unknown error occurred';\n  \n  const handleRefresh = () => {\n    window.location.reload();\n  };\n  \n  return (\n    <ErrorContainer>\n      <ErrorTitle>{errorMessage.title}</ErrorTitle>\n      <ErrorDetails>\n        {errorMessage.description}\n      </ErrorDetails>\n      <ErrorDetails>\n        <strong>Details:</strong> {message}\n      </ErrorDetails>\n      <ErrorAction>\n        <button onClick={handleRefresh}>Refresh the page</button>\n      </ErrorAction>\n    </ErrorContainer>\n  );\n};\n\nexport default ErrorMessage;"],"names":["didWarnUncachedGetSnapshot","uSESKey","realHook","React","useSyncExternalStore","subscribe","getSnapshot","getServerSnapshot","value","invariant","_a","React.useState","inst","forceUpdate","canUseLayoutEffect","React.useLayoutEffect","checkIfSnapshotChanged","React.useEffect","wrapperSymbol","wrapHook","hookName","useHook","clientOrObsQuery","queryManager","wrappers","wrapper","hasOwnProperty","noop","lastWatchOptions","useQuery","query","options","useQuery_","useApolloClient","useQueryInternals","result","obsQueryFields","React.useMemo","__assign","useInternalState","client","renderPromises","makeWatchQueryOptions","createInternalState","previous","verifyDocumentType","DocumentType","internalState","getObsQueryOptions","updateInternalState","onQueryExecuted","watchQueryOptions","_b","resultData","newInternalState","React.useContext","getApolloContext","isSyncSSR","disableNetworkFetches","ssrAllowed","partialRefetch","createMakeWatchQueryOptions","observable","useResubscribeIfNecessary","bindObservableMethods","useRegisterSSRObservable","useObservableSubscriptionResult","callbacks","callbackRef","React.useRef","resultOverride","ssrDisabledResult","skipStandbyResult","previousData","currentResultOverride","toQueryResult","React.useCallback","handleStoreChange","onNext","previousResult","equal","setResult","onError","error","subscription","NetworkStatus","getCurrentResult","skip","defaultOptions","otherOptions","__rest","getDefaultFetchPolicy","queryHookOptions","toMerge","globalDefaults","compact","mergeOptions","nextResult","isNonEmptyArray","ApolloError","unsafeHandlePartialRefetch","handleErrorOrCompleted","previousNetworkStatus","error_1","toApolloError","queryHookDefaultOptions","clientDefaultOptions","data","resultWithoutPartial","queryResult","maybeDeepFreeze","gql","GET_USERS","GET_USER_MOODS","GET_PUBLIC_MOODS","GET_MOOD_STREAK","GET_SENT_HUGS","GET_RECEIVED_HUGS","GET_MY_HUG_REQUESTS","GET_PENDING_HUG_REQUESTS","GET_COMMUNITY_HUG_REQUESTS","detectErrorType","context","message","getErrorMessage","errorType","ErrorContainer","styled","ErrorTitle","ErrorDetails","ErrorAction","ErrorMessage","jsx","errorMessage","handleRefresh"],"mappings":"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","x_google_ignoreList":[0,1,2]}