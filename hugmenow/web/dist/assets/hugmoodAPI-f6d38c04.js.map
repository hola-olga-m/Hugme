{"version":3,"file":"hugmoodAPI-f6d38c04.js","sources":["../../src/services/hugmoodAPI.js"],"sourcesContent":["/**\n * HugMood API Service\n * Provides real-time WebSocket and subscription functionality\n */\n\nimport { gql } from '@apollo/client';\n\n// Get the Apollo client - this will be initialized from the app\nlet apolloClient;\n\n/**\n * Initialize the Apollo Client\n * This should be called from a component with access to the Apollo client\n */\nexport const initApolloClient = (client) => {\n  apolloClient = client;\n  console.log('HugMoodAPI: Apollo client initialized');\n};\n\n// Define GraphQL subscription queries\nconst NEW_HUG_SUBSCRIPTION = gql`\n  subscription OnNewHug($userId: ID!) {\n    newHug(userId: $userId) {\n      id\n      senderId\n      senderName\n      senderAvatar\n      recipientId\n      hugTypeId\n      hugTypeName\n      message\n      sentAt\n      status\n    }\n  }\n`;\n\nconst NEW_HUG_REQUEST_SUBSCRIPTION = gql`\n  subscription OnNewHugRequest($userId: ID!) {\n    newHugRequest(userId: $userId) {\n      id\n      requesterId\n      requesterName\n      requesterAvatar\n      recipientId\n      hugTypeId\n      hugTypeName\n      message\n      requestedAt\n      status\n    }\n  }\n`;\n\nconst HUG_REQUEST_UPDATE_SUBSCRIPTION = gql`\n  subscription OnHugRequestUpdate($userId: ID!) {\n    hugRequestUpdate(userId: $userId) {\n      id\n      requesterId\n      requesterName\n      recipientId\n      recipientName\n      hugTypeId\n      hugTypeName\n      status\n      responseMessage\n    }\n  }\n`;\n\n// In-memory store of active subscriptions\nconst activeSubscriptions = new Map();\n\n/**\n * Subscribe to new hugs for a user\n * @param {string} userId - The user ID to subscribe for\n * @param {function} callback - Callback function to execute when a new hug is received\n * @returns {function} Unsubscribe function\n */\nexport const subscribeNewHugs = (userId, callback) => {\n  try {\n    // Because we're in a simplified version without WebSockets,\n    // we'll use polling instead of subscriptions\n    \n    // Set up a polling interval to check for new hugs\n    const intervalId = setInterval(async () => {\n      try {\n        if (!apolloClient) {\n          console.error('Apollo client not initialized in hugmoodAPI');\n          return;\n        }\n        const { data } = await apolloClient.query({\n          query: gql`\n            query GetLatestHugs($userId: ID!) {\n              receivedHugs(userId: $userId, limit: 5) {\n                id\n                senderId\n                senderName\n                senderAvatar\n                recipientId\n                hugTypeId\n                hugTypeName\n                message\n                sentAt\n                status\n              }\n            }\n          `,\n          variables: { userId },\n          fetchPolicy: 'network-only'\n        });\n        \n        // Check if there are new hugs (simplified check - in real app would track last seen)\n        if (data.receivedHugs && data.receivedHugs.length > 0) {\n          // In a real implementation, we'd check if these are actually new\n          // For now, just simulate by occasionally triggering the callback\n          if (Math.random() < 0.1) { // 10% chance to simulate a new hug\n            callback(data.receivedHugs[0]);\n          }\n        }\n      } catch (error) {\n        console.error('Error polling for new hugs:', error);\n      }\n    }, 30000); // Poll every 30 seconds\n    \n    // Store the subscription info\n    const subKey = `newHugs-${userId}`;\n    activeSubscriptions.set(subKey, intervalId);\n    \n    // Return unsubscribe function\n    return () => {\n      clearInterval(intervalId);\n      activeSubscriptions.delete(subKey);\n    };\n  } catch (error) {\n    console.error('Error setting up hug subscription:', error);\n    return () => {}; // Return empty unsubscribe function\n  }\n};\n\n/**\n * Subscribe to new hug requests for a user\n * @param {string} userId - The user ID to subscribe for\n * @param {function} callback - Callback function to execute when a new request is received\n * @returns {function} Unsubscribe function\n */\nexport const subscribeNewHugRequests = (userId, callback) => {\n  try {\n    // Set up a polling interval for new hug requests\n    const intervalId = setInterval(async () => {\n      try {\n        if (!apolloClient) {\n          console.error('Apollo client not initialized in hugmoodAPI');\n          return;\n        }\n        const { data } = await apolloClient.query({\n          query: gql`\n            query GetLatestHugRequests($userId: ID!) {\n              receivedHugRequests(userId: $userId, limit: 5) {\n                id\n                requesterId\n                requesterName\n                requesterAvatar\n                recipientId\n                hugTypeId\n                hugTypeName\n                message\n                requestedAt\n                status\n              }\n            }\n          `,\n          variables: { userId },\n          fetchPolicy: 'network-only'\n        });\n        \n        // Check if there are new requests\n        if (data.receivedHugRequests && data.receivedHugRequests.length > 0) {\n          // In a real implementation, we'd check if these are actually new\n          // For now, just simulate by occasionally triggering the callback\n          if (Math.random() < 0.05) { // 5% chance to simulate a new request\n            callback(data.receivedHugRequests[0]);\n          }\n        }\n      } catch (error) {\n        console.error('Error polling for new hug requests:', error);\n      }\n    }, 30000); // Poll every 30 seconds\n    \n    // Store the subscription info\n    const subKey = `newHugRequests-${userId}`;\n    activeSubscriptions.set(subKey, intervalId);\n    \n    // Return unsubscribe function\n    return () => {\n      clearInterval(intervalId);\n      activeSubscriptions.delete(subKey);\n    };\n  } catch (error) {\n    console.error('Error setting up hug request subscription:', error);\n    return () => {}; // Return empty unsubscribe function\n  }\n};\n\n/**\n * Subscribe to updates on existing hug requests\n * @param {string} userId - The user ID to subscribe for\n * @param {function} callback - Callback function to execute when a request is updated\n * @returns {function} Unsubscribe function\n */\nexport const subscribeHugRequestUpdates = (userId, callback) => {\n  try {\n    // Set up a polling interval for hug request updates\n    const intervalId = setInterval(async () => {\n      try {\n        if (!apolloClient) {\n          console.error('Apollo client not initialized in hugmoodAPI');\n          return;\n        }\n        const { data } = await apolloClient.query({\n          query: gql`\n            query GetSentHugRequestUpdates($userId: ID!) {\n              sentHugRequests(userId: $userId) {\n                id\n                requesterId\n                requesterName\n                recipientId\n                recipientName\n                hugTypeId\n                hugTypeName\n                status\n                responseMessage\n                requestedAt\n              }\n            }\n          `,\n          variables: { userId },\n          fetchPolicy: 'network-only'\n        });\n        \n        // Check if there are any updates (simplified check)\n        if (data.sentHugRequests && data.sentHugRequests.length > 0) {\n          // In a real implementation, we'd check if the status has changed\n          // For now, just simulate by occasionally triggering the callback\n          if (Math.random() < 0.05) { // 5% chance to simulate an update\n            callback(data.sentHugRequests[0]);\n          }\n        }\n      } catch (error) {\n        console.error('Error polling for hug request updates:', error);\n      }\n    }, 30000); // Poll every 30 seconds\n    \n    // Store the subscription info\n    const subKey = `hugRequestUpdates-${userId}`;\n    activeSubscriptions.set(subKey, intervalId);\n    \n    // Return unsubscribe function\n    return () => {\n      clearInterval(intervalId);\n      activeSubscriptions.delete(subKey);\n    };\n  } catch (error) {\n    console.error('Error setting up hug request update subscription:', error);\n    return () => {}; // Return empty unsubscribe function\n  }\n};\n\n/**\n * Clean up all active subscriptions\n */\nexport const cleanupAllSubscriptions = () => {\n  activeSubscriptions.forEach((intervalId) => {\n    clearInterval(intervalId);\n  });\n  activeSubscriptions.clear();\n};"],"names":["apolloClient","initApolloClient","client","gql","activeSubscriptions","subscribeNewHugs","userId","callback","intervalId","data","error","subKey","subscribeNewHugRequests","subscribeHugRequestUpdates","cleanupAllSubscriptions"],"mappings":"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"}